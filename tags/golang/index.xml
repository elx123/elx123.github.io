<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Golang on Jane - A super concise theme for Hugo</title>
    <link>https://elx123.github.io/tags/golang/</link>
    <description>Recent content in Golang on Jane - A super concise theme for Hugo</description>
    <generator>Hugo</generator>
    <language>en</language>
    <managingEditor>me@example.com (elx123)</managingEditor>
    <webMaster>me@example.com (elx123)</webMaster>
    <copyright>elx123</copyright>
    <lastBuildDate>Mon, 14 Jan 2019 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://elx123.github.io/tags/golang/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Weighted Random Selection</title>
      <link>https://elx123.github.io/post/weightsort/</link>
      <pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><author>me@example.com (elx123)</author>
      <guid>https://elx123.github.io/post/weightsort/</guid>
      <description>&lt;!-- more --&gt;&#xA;&lt;div id=&#34;outline-container-headline-1&#34; class=&#34;outline-2&#34;&gt;&#xA;&lt;h2 id=&#34;headline-1&#34;&gt;&#xA;简介&#xA;&lt;/h2&gt;&#xA;&lt;div id=&#34;outline-text-headline-1&#34; class=&#34;outline-text-2&#34;&gt;&#xA;&lt;p&gt;最近在项目中遇到了加密权重算法,记录下使用心得&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&lt;div id=&#34;outline-container-headline-2&#34; class=&#34;outline-2&#34;&gt;&#xA;&lt;h2 id=&#34;headline-2&#34;&gt;&#xA;问题描述&#xA;&lt;/h2&gt;&#xA;&lt;div id=&#34;outline-text-headline-2&#34; class=&#34;outline-text-2&#34;&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Given a list of items where each item has a weight (integer value), select a random item from the list based on that weight.&lt;/li&gt;&#xA;&lt;li&gt;The key requirement — items with a higher weight value are more likely to be returned. So even the lowest weighted value will still sometimes be returned from the function.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&lt;div id=&#34;outline-container-headline-3&#34; class=&#34;outline-2&#34;&gt;&#xA;&lt;h2 id=&#34;headline-3&#34;&gt;&#xA;解决思路&#xA;&lt;/h2&gt;&#xA;&lt;div id=&#34;outline-text-headline-3&#34; class=&#34;outline-text-2&#34;&gt;&#xA;&lt;p&gt;1.Add up all the weights for all the items in the list&#xA;2.Pick a number at random between 1 and the sum of the weights&#xA;3.Iterate over the items&#xA;4.For the current item, subtract the item’s weight from the random number that was originally picked&#xA;5.Compare the result to zero. If less than or equal to zero then break otherwise keep iterating. The key is that the larger the weight the more likely to be less than zero when compared to the random selection between zero and the sum of weights.&#xA;6.If not less than zero, continue iterating over the list, all the while subtracting more and more weights off the random number chosen from the sum of the weights.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Golang位运算符的溢出情况</title>
      <link>https://elx123.github.io/post/golang_%3c%3c/</link>
      <pubDate>Sun, 23 Dec 2018 00:00:00 +0000</pubDate><author>me@example.com (elx123)</author>
      <guid>https://elx123.github.io/post/golang_%3c%3c/</guid>
      <description>&lt;!-- more --&gt;&#xA;&lt;div id=&#34;outline-container-headline-1&#34; class=&#34;outline-2&#34;&gt;&#xA;&lt;h2 id=&#34;headline-1&#34;&gt;&#xA;简介&#xA;&lt;/h2&gt;&#xA;&lt;div id=&#34;outline-text-headline-1&#34; class=&#34;outline-text-2&#34;&gt;&#xA;&lt;p&gt;在编码过程中,经常会遇到使用逻辑运算符的情况,其中对于溢出操作需要特别小心&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&lt;div id=&#34;outline-container-headline-2&#34; class=&#34;outline-2&#34;&gt;&#xA;&lt;h2 id=&#34;headline-2&#34;&gt;&#xA;介绍&#xA;&lt;/h2&gt;&#xA;&lt;div id=&#34;outline-text-headline-2&#34; class=&#34;outline-text-2&#34;&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;编译型语言，编译器的静态求值是自然的。&lt;/li&gt;&#xA;&lt;li&gt;必须使用强制类型转换。甚至于对一个uint16变量赋uint8的值都是不允许的。&lt;/li&gt;&#xA;&lt;li&gt;整数字面值不包含存储空间的大小，可以直接赋给各种uintX（必须不溢出）。&lt;/li&gt;&#xA;&lt;li&gt;&amp;lt;&amp;lt;运算的结果的类型，以左侧操作数为准。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div id=&#34;outline-container-headline-3&#34; class=&#34;outline-3&#34;&gt;&#xA;&lt;h3 id=&#34;headline-3&#34;&gt;&#xA;直接表现为&#xA;&lt;/h3&gt;&#xA;&lt;div id=&#34;outline-text-headline-3&#34; class=&#34;outline-text-3&#34;&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;静态求值的规则是先不顾代码范围，强制求值，之后再塞回目标的存储空间中&lt;/li&gt;&#xA;&lt;li&gt;对变量左移的时候，会直接考虑存储空间大小，将左移的数据丢弃&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&lt;div id=&#34;outline-container-headline-4&#34; class=&#34;outline-2&#34;&gt;&#xA;&lt;h2 id=&#34;headline-4&#34;&gt;&#xA;反例&#xA;&lt;/h2&gt;&#xA;&lt;div id=&#34;outline-text-headline-4&#34; class=&#34;outline-text-2&#34;&gt;&#xA;&lt;div class=&#34;src src-go&#34;&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;c_i8&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;uint8&lt;/span&gt; = &lt;span style=&#34;color:#ae81ff&#34;&gt;255&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i16&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;uint16&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;i16&lt;/span&gt; = uint16(&lt;span style=&#34;color:#a6e22e&#34;&gt;c_i8&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;) &lt;span style=&#34;color:#75715e&#34;&gt;// constant 4080 overflows uint8&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;i16&lt;/span&gt; = uint16(uint8(&lt;span style=&#34;color:#ae81ff&#34;&gt;255&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;) &lt;span style=&#34;color:#75715e&#34;&gt;// constant 4080 overflows uint8&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&lt;p&gt;因为&amp;lt;&amp;lt;左侧都是uint8，所以最终的结果也是uint8，则得出的结果装不下uint8就会报错，哪怕最后准备了uint16的容器也不行&lt;/p&gt;</description>
    </item>
    <item>
      <title>Golang float</title>
      <link>https://elx123.github.io/post/float64/</link>
      <pubDate>Sun, 14 Oct 2018 00:00:00 +0000</pubDate><author>me@example.com (elx123)</author>
      <guid>https://elx123.github.io/post/float64/</guid>
      <description>&lt;!-- more --&gt;&#xA;&lt;p&gt;最近在工作遇到float的精度问题,记录下解决思路&lt;/p&gt;&#xA;&lt;div id=&#34;outline-container-headline-1&#34; class=&#34;outline-2&#34;&gt;&#xA;&lt;h2 id=&#34;headline-1&#34;&gt;&#xA;简介&#xA;&lt;/h2&gt;&#xA;&lt;div id=&#34;outline-text-headline-1&#34; class=&#34;outline-text-2&#34;&gt;&#xA;&lt;p&gt;浮点数数据格式有许多种,IEEE754标准的浮点数与IBM格式浮点数用的比较多&lt;br&gt;&#xA;Go提供了两种size的浮点数,float32和float64.它们的算术规范是由IEEE754国际标准定义，现代CPU都实现了这个规范.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
